<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title>全景过渡</title>
    <meta charset="utf-8">
    <meta name="viewport" content="user-scalable=no, initial-scale=1">
    <link rel="stylesheet" href="css/jquery.contextMenu.css" type="text/css"/>
    <style>
        body {
            margin: 0px;
            overflow: hidden;
            z-index: -1000;
        }
        /* cursors: [JavaScript - Mouse Cursor Styles](http://www.javascripter.net/faq/stylesc.htm) */
        body.move, body.move *                   { cursor: move !important; }
        body.crosshair, body.crosshair *        { cursor: crosshair !important; }
        body.pointer, body.pointer *             { cursor: pointer !important; }
        body.all-scroll, body.all-scroll *      { cursor: all-scroll !important; }

        .pic {
            position: absolute;
            bottom: 0px;
            margin: 2px;
            padding: 2px;
            border: 1px solid white;
            background-color: rgba(0,0,0,0.4);
        }
        .pic1 { left:  0px; }
        .pic2 { right: 0px; }

        #context-menu {
            // visibility: hidden;
            background-color: white;
            border: 1px solid grey;
            width: 200px;
            height: 300px;
        }
        .labels > span > ul {
            margin: 0;
            padding: 0;
            list-style: none;
            display: block;
            float: none;
        }
        .labels > span > ul > li {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 1px solid #CCC;
            overflow: hidden;
            text-indent: -2000px;
        }
        .labels > span > ul > li.selected,
        .labels > span > ul > li:hover { border: 1px solid #000; }
        .labels > span > ul > li + li { margin-left: 5px; }
        .labels > span > ul > li.label1 { background: red; }
        .labels > span > ul > li.label2 { background: green; }
        .labels > span > ul > li.label3 { background: blue; }
        .labels > span > ul > li.label4 { background: yellow; }

        .log {
            position: absolute;
            left: 0px;
            bottom: 0px;
            margin: 2px;
            padding: 2px;
            border: 1px solid white;
            color: white;
            font-size: 8px;
            max-width: 50%;
            max-height: 60%;
            min-width: 200px;
            background-color: rgba(0,0,0,0.4);
            overflow-y: auto;
            z-index: 1000;
        }
        #cursor-log {
            margin: 0;
            padding: 2px;
            border: none;
            min-width: 0px;
            min-height: 0px;
        }
    </style>
</head>
<body>

<div id="container"></div>
<div class="log" id="cursor-log"><pre><code id="cursor-log-code"></code></pre></div>
<div class="pic pic1"><a href="texture1.jpg" target="_blank"><img id="pic1" src="texture1.jpg" style="width:200px;height:100px;" alt="左" /></a></div>
<div class="pic pic2"><a href="texture2.jpg" target="_blank"><img id="pic2" src="texture2.jpg" style="width:200px;height:100px;" alt="右" /></a></div>

<script src="js/jquery.min.js"></script>
<script src="js/three.js"></script>
<script src="js/utils.js"></script>
<script src="js/CanvasRenderer.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Projector.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/DeviceOrientationControls.js"></script>
<script src="js/dat.gui.min.js"></script>
<script src="js/jquery.ui.position.js"></script>
<script src="js/jquery.contextMenu.js"></script>
<script src="js/CubemapToEquirectangular.js"></script>
<script src="js/tween.min.js"></script>

<script>
    "use strict";

    var Config = function() {
        this.points = [];

        var _this = this;
        this.clock = new THREE.Clock();

        // this.lonSpeed = 0.1; TODO, 带有加速度的 delta

        this.material1 = new THREE.MeshBasicMaterial(); this.material1.transparent = true;
        this.material2 = new THREE.MeshBasicMaterial(); this.material2.transparent = true;

        this.group2Distance = 1000;
        this.group2OffsetNorth = 90;
        this.sphereScale = 1;
        this.sphereScale0 = this.sphereScale;

        this.showPic = false;

        this.toggleCamHelperVisibility = function() {
            var helpers;
            return function() {
                if (helpers === undefined && config.cam0Helper !== undefined) {
                    helpers = [
                        config.cam0Helper,
                        config.cam1Helper,
                        config.cam2Helper,
                        config.camXHelper
                    ];
                }
                Util.toogleVisibility(helpers);
            }
        }();
        this.toggleAxisHelperVisibility = function() {
            var helpers;
            return function() {
                if (helpers === undefined && config.globalAxis !== undefined) {
                    helpers = [
                        config.globalAxis,
                        config.group1Axis,
                        config.group2Axis
                    ];
                }
                Util.toogleVisibility(helpers);
            }
        }();

        this.raycastUV = false;

        this.fov = 60; // 全局 fov：cam 0/1/2
        this.fovMin = 10;
        this.fovMax = 100;
        this.near = 10;
        this.nearMin = 0;
        this.nearMax = 1000;
        this.far = 10000;
        this.farMin = 100;
        this.farMax = 10000;

        this.alpha = 1.0;
        this.deltaMove = 8;

        // axis helper
        this.globalAxis = new THREE.AxisHelper(1000);
        this.group1Axis = new THREE.AxisHelper(1000);
        this.group2Axis = new THREE.AxisHelper(1000);
        this.cam0Axis   = new THREE.AxisHelper(1000);

        // cameras
        this.camera1 = new THREE.PerspectiveCamera(this.fov, window.innerWidth / window.innerHeight, 100, 2000);
        this.camera2 = new THREE.PerspectiveCamera(this.fov, window.innerWidth / window.innerHeight, 100, 2000);
        this.camera0 = new THREE.PerspectiveCamera(this.fov, window.innerWidth / window.innerHeight, 100, 200000); this.camera0.position.set(-2000, 0, 0);
        this.cameraX = new THREE.PerspectiveCamera(this.fov, window.innerWidth / window.innerHeight, 100, 2000);

        this.camera0.name = "CAM 0";
        this.camera1.name = "CAM 1";
        this.camera2.name = "CAM 2";
        this.cameraX.name = "CAM X";

        this.camera1.isCamP = true; // panoramic camera
        this.camera2.isCamP = true;
        this.camera0.isCam0 = true; // orbit controlled cam
        this.cameraX.isCamX = true;

        this.camera1.lon = this.camera2.lon = this.cameraX.lon = 0;
        this.camera1.lat = this.camera2.lat = this.cameraX.lat = 0;

        this.cameraIndex = 1; // init to cam 1

        this.cam1Helper = new THREE.CameraHelper( this.camera1 );
        this.cam2Helper = new THREE.CameraHelper( this.camera2 );
        this.camXHelper = new THREE.CameraHelper( this.cameraX );
        this.cam0Helper = new THREE.CameraHelper( this.camera0 );

        // groups
        this.group1 = new THREE.Group();
        this.group2 = new THREE.Group();

        // screenshot panorama
        this.savePanorama = function() {
            var equiManaged = new CubemapToEquirectangular( renderer, true );
            equiManaged.setSize( 2048, 1024 );
            equiManaged.update( camera, scene );
        };
        this.needUpdateScreenshot = false;

        // able to edit offset to north?
        this.canEditOffsetToNorth = false;
        this.offsetToNorth1 = 0;
        this.offsetToNorth2 = 0;

        this.freeze = false;

        this.dual = function() {
            $(".close-button").click();
            // matchesGroup1.visible = matchesGroup2.visible = false;
            // _this.freeze = true;
            _this.alpha0 = _this.alpha;
        };

        this.light = new THREE.AmbientLight(0xffffff); // can be turned off
        this.gridXZ = new THREE.GridHelper(10000, 100, 0x888888, 0x888888);
        this.gridXZ.visible = false;
    };
    var config = new Config();
    if (!config.showPic) { $(".pic").hide(); }

    var gui = new dat.GUI(); gui.closed = true;

    gui.add(config, 'raycastUV').listen().name("Raycast UV");

    function updateGroup2Position() {
        var theta = THREE.Math.degToRad(config.group2OffsetNorth);
        var radius = config.group2Distance;
        var x =  Math.sin(theta) * radius;
        var z = -Math.cos(theta) * radius;
        config.group2.position.set(x,0,z);
    }

    var setScale = function(geometry) {
        var scale0 = 1;
        var geometry = geometry;
        if (geometry) {
            return function(scale) {
                var s = scale / scale0;
                geometry.scale(s,s,s);
                scale0 = scale;
            };
        } else {
            return function(){};
        }
    };

    sphere = new THREE.SphereGeometry( 500, 64, 32 ); sphere.scale( -1, 1, 1 );

    var geometryFolder = gui.addFolder('全景位置'); // geometryFolder.closed = false;
    geometryFolder.add(config, 'group2Distance').min(0).max(10000).step(1).onChange(updateGroup2Position).name("距离")
    geometryFolder.add(config, 'group2OffsetNorth').min(0).max(360).step(1).onChange(updateGroup2Position).name("角度");
    geometryFolder.add(config, 'sphereScale').min(0.5).max(10).step(0.1).onChange(setScale(sphere)).name("大小");
    var offsetFolder = geometryFolder.addFolder('偏移量');
    var onShowOffset = function (show) {
        if (show) {
            config.offsetController1 = offsetFolder.add(config, 'offsetToNorth1').name("图 1 偏移量").min(0).max(360).step(0.1).listen().onChange(updateOffsetToNorth(config.group1));
            config.offsetController2 = offsetFolder.add(config, 'offsetToNorth2').name("图 2 偏移量").min(0).max(360).step(0.1).listen().onChange(updateOffsetToNorth(config.group2));
        } else {
            if (config.offsetController1) { offsetFolder.remove(config.offsetController1); }
            if (config.offsetController2) { offsetFolder.remove(config.offsetController2); }
        }
    };
    offsetFolder.add(config, 'canEditOffsetToNorth').onChange(onShowOffset).name("修改偏移量");


    // gui.add(config, 'fov').min(10).max(100).step(1).listen().name("视场角").onChange(updateCameraFov);
    gui.add(config, 'savePanorama').name("把场景存成全景图");
    gui.add(config, 'deltaMove').min(1).max(10).step(1).listen().name("移动速度");

    var flags = gui.addFolder("变量的设定");
    flags.add(config, 'showPic').name("显示原图").onFinishChange(function (show){ if (show) { $(".pic").show(); } else { $(".pic").hide(); } });
    flags.add(config.light, 'visible').listen().name("显示灯光");
    flags.add(config.gridXZ, 'visible').listen().name("显示地平线");
    flags.add(config, 'toggleCamHelperVisibility').listen().name("显示/隐藏相机");
    flags.add(config.cam0Helper, 'visible').listen().name("显示 CAM 0");
    flags.add(config.cam1Helper, 'visible').listen().name("显示 CAM 1");
    flags.add(config.cam2Helper, 'visible').listen().name("显示 CAM 2");
    flags.add(config.camXHelper, 'visible').listen().name("显示 CAM X");
    flags.add(config, 'toggleAxisHelperVisibility').listen().name("显示/隐藏坐标系");
    flags.add(config.globalAxis, 'visible').listen().name("显示全局   坐标系");
    flags.add(config.group1Axis, 'visible').listen().name("显示全景 1 坐标系");
    flags.add(config.group2Axis, 'visible').listen().name("显示全景 2 坐标系");

    function updateOffsetToNorth(group) {
        var _group = group;
        return function (offset) {
            var p = _group.position.clone();
            _group.matrix.identity();
            _group.applyMatrix(
                new THREE.Matrix4().makeTranslation(p.x,p.y,p.z).multiply(
                    new THREE.Matrix4().makeRotationY(THREE.Math.degToRad(offset))
                )
            );
        }
    }

    var createFeaturePoint = function() {
        var point = new THREE.SphereGeometry( 1, 64, 32); config.point = point;
        var mat1 = new THREE.MeshBasicMaterial( { color: 0x000000, transparent: true, opacity: 0.0 } );
        var mat2 = new THREE.MeshBasicMaterial( { color: 0x0000ff, side: THREE.DoubleSide } );
        // shit
        return function(lon, lat, radius) {
            var group = new THREE.Group();
            group.setColor = function(r,g,b) {
                group.children[1].material.color.setRGB(r,g,b);
            };
            var pt = new THREE.Mesh( point, mat1 );
            var ct = new THREE.Mesh( point, mat2.clone() );
            pt.scale.multiplyScalar(0.1);
            ct.scale.multiplyScalar(10);
            group.add( pt );
            group.add( ct );
            if (lon !== undefined && lat !== undefined) {
                var radius = radius || 400;
                var v = Util.lonlat2xyz(lon, lat, radius);
                group.position.set(v.x,v.y,v.z);
                scene.add(group);
                config.points.push(group);
            }
            return group;
        };
    }();

    var cams = [config.camera0, config.camera1, config.camera2, config.cameraX];
    function switchToCam(index) {
        var index = index || config.cameraIndex+1;
        config.cameraIndex = index%cams.length;
        camera = cams[config.cameraIndex];
        if (config.cam0Controls !== undefined) {
            config.cam0Controls.enabled = camera.isCam0 || false;
        }
        console.log("active camera: "+camera.name);
    }
    var camFolder = gui.addFolder('相机设定');
    camFolder.add(config, 'cameraIndex', {
        "CAM 1": 1,
        "CAM 2": 2,
        "CAM X": 3,
        "CAM 0": 0
    } ).listen().onChange(switchToCam).name("当前相机");
    camFolder.add(config, 'fov').min(config.fovMin).max(config.fovMax).step(1).listen().onChange(function(fov){
        // config.camera0.fov =
        config.camera1.fov = config.camera2.fov = config.cameraX.fov = fov;
    }).name("全局 fov");
    camFolder.add(config, 'near').min(config.nearMin).max(config.nearMax).step(1).listen().onChange(function(near){
        if (config.near > config.far) {
            config.near = config.far;
        }
        config.camera1.near = config.camera2.near = config.cameraX.near = config.near;
    }).name("全局 near");
    camFolder.add(config, 'far').min(config.farMin).max(config.farMax).step(1).listen().onChange(function(near){
        if (config.far < config.near) {
            config.far = config.near;
        }
        config.camera1.far = config.camera2.far = config.cameraX.far = config.far;
    }).name("全局 far");

    var cam1Folder = camFolder.addFolder('CAM 1'); cam1Folder.closed = false;
    var cam2Folder = camFolder.addFolder('CAM 2'); cam2Folder.closed = false;
    var camXFolder = camFolder.addFolder('CAM X'); camXFolder.closed = false;

    cam1Folder.add(config.camera1, "fov").min(config.fovMin).max(config.fovMax).step(1).listen().onChange(function(){ });
    cam2Folder.add(config.camera2, "fov").min(config.fovMin).max(config.fovMax).step(1).listen().onChange(function(){ });
    camXFolder.add(config.cameraX, "fov").min(config.fovMin).max(config.fovMax).step(1).listen().onChange(function(){ });

    cam1Folder.add(config.camera1, "near").min(config.nearMin).max(config.nearMax).step(1).listen().onChange(function(){
        if (config.camera1.near > config.camera1.far) {
            config.camera1.near = config.camera1.far;
        }
    });
    cam2Folder.add(config.camera2, "near").min(config.nearMin).max(config.nearMax).step(1).listen().onChange(function(){
        if (config.camera2.near > config.camera2.far) {
            config.camera2.near = config.camera2.far;
        }
    });
    camXFolder.add(config.cameraX, "near").min(config.nearMin).max(config.nearMax).step(1).listen().onChange(function(){
        if (config.cameraX.near > config.cameraX.far) {
            config.cameraX.near = config.cameraX.far;
        }
    });

    cam1Folder.add(config.camera1, "far").min(config.farMin).max(config.farMax).step(1).listen().onChange(function(){
        if (config.camera1.far < config.camera1.near) {
            config.camera1.far = config.camera1.near;
        }
    });
    cam2Folder.add(config.camera2, "far").min(config.farMin).max(config.farMax).step(1).listen().onChange(function(){
        if (config.camera2.far < config.camera2.near) {
            config.camera2.far = config.camera2.near;
        }
    });
    camXFolder.add(config.cameraX, "far").min(config.farMin).max(config.farMax).step(1).listen().onChange(function(){
        if (config.cameraX.far < config.cameraX.near) {
            config.cameraX.far = config.cameraX.near;
        }
    });

    var onAlphaChange = function (value, value2) {
        var value2 = value2 || 1-value;
        config.material1.opacity = value;
        config.material2.opacity = value2;
    };
    gui.add(config, 'alpha').min(0.0).max(1.0).step(0.01).listen().onChange(onAlphaChange).name("颜色混合比例");
    gui.add(config.material1, 'opacity').min(0.0).max(1.0).step(0.01).listen().name("全景 1 不透明度");
    gui.add(config.material2, 'opacity').min(0.0).max(1.0).step(0.01).listen().name("全景 2 不透明度");

    config.featurePointScale = 1.0;
    gui.add(config, 'featurePointScale').min(0.5).max(10).step(0.1).onChange(setScale(config.point)).name("特征点大小");

    function setCursorStyle(style) {
        $("body").removeClass();
        if (style) {
            $("body").addClass(style);
        }
    }

    var $info = config.$info = (config.$info || $("#cursor-log-code"));
    var $iBox = config.$iBox = (config.$iBox || config.$info.parent().parent());

    var container, camera, scene, renderer, sphere, controls;
    var raycaster = new THREE.Raycaster();

    var isUserInteracting = false;
    var onPointerDownPointerX = 0, onPointerDownPointerY = 0, onPointerDownLon = 0, onPointerDownLat = 0;

    var getIntersects = function ( point, objects, recursive ) {
        var mouse = new THREE.Vector2( ( point.x * 2 ) - 1, - ( point.y * 2 ) + 1  );
        raycaster.setFromCamera( mouse, camera );
        return raycaster.intersectObjects( objects, recursive);
    };

    var isDesktop = !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i);

    window.addEventListener('load', function() {

        // scene
        scene = new THREE.Scene();
        scene.add(config.light);
        scene.add(config.gridXZ);

        /*
        var s = new THREE.Mesh( new THREE.SphereGeometry( 50, 64, 32 ));
        s.position.set(300, 20, 10);
        var m = new THREE.Mesh( s, new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: true}));
        scene.add(m);
        config.points.push(m);
        */

        // cameras
        scene.add(config.camera1).add(config.cam1Helper );
        scene.add(config.camera2).add(config.cam2Helper );
        scene.add(config.cameraX).add(config.camXHelper );
        scene.add(config.camera0).add(config.cam0Helper );

        // renderer
        container = document.getElementById( 'container' );
        if(Detector.webgl){
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                preserveDrawingBuffer: true
            });
        } else {
            renderer = new THREE.CanvasRenderer();
        }
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = 0;
        container.appendChild(renderer.domElement);

        // controls
        config.cam0Controls = new THREE.OrbitControls( config.camera0, renderer.domElement );
        switchToCam(config.cameraIndex);
        controls = new THREE.DeviceOrientationControls( camera );
        if (isDesktop) { controls.enabled = false; }

        // meshes

        config.texture1 = new THREE.TextureLoader().load("texture1.jpg");
        config.texture2 = new THREE.TextureLoader().load("texture2.jpg");
        config.texture1.wrapS = config.texture2.wrapS = THREE.RepeatWrapping;
        config.texture1.wrapT = config.texture2.wrapT = THREE.RepeatWrapping;

        config.material1.map = config.texture1; config.material1.side = THREE.DoubleSide;
        config.material2.map = config.texture2; config.material2.side = THREE.DoubleSide;


        scene.add(config.globalAxis);
        scene.add(config.cam0Axis);

        config.mesh1 = new THREE.Mesh( sphere, config.material1 );
        config.mesh2 = new THREE.Mesh( sphere, config.material2 );

        // groups
        scene.add( config.group1.add(config.group1Axis).add(config.mesh1) );
        scene.add( config.group2.add(config.group2Axis).add(config.mesh2) );

        updateGroup2Position();

        // init
        onAlphaChange(config.alpha);
        config.toggleCamHelperVisibility();
        config.toggleAxisHelperVisibility();

        createFeaturePoint(0,0);
        createFeaturePoint(20, 20);
        createFeaturePoint(30, 10);
        animate();

        window.addEventListener('keydown', onKeyDown, false );
        window.addEventListener('resize', function() {
            var aspect = window.innerWidth / window.innerHeight;
            [ config.camera1, config.camera2, config.cameraX, config.camera0 ].forEach(function(cam){
                cam.aspect = aspect;
                cam.updateProjectionMatrix();
            });
            renderer.setSize( window.innerWidth, window.innerHeight );
        }, false);
        document.addEventListener( 'mousedown', function(event) {
            if (config.freeze) { return; }
            //
            if (camera.isCam0) {
                config.gridXZ.visible0 = config.gridXZ.visible;
                config.gridXZ.visible = true;
                return;
            } else if (camera.isCamP) {
                if (config.raycastUV) {
                    var array = [event.clientX / window.innerWidth, event.clientY / window.innerHeight];
                    var intersects = getIntersects( new THREE.Vector2().fromArray(array), config.points, false);
                    // var intersects = getIntersects( new THREE.Vector2().fromArray(array), config.points, true);
                    if (intersects.length > 0) {
                        var point = intersects[0];
                        point.setColor(Math.random(), Math.random(), Math.random());
                    } else {
                        console.log("no match");
                    }
                } else {
                    setCursorStyle("all-scroll");
                    isUserInteracting = true;
                    onPointerDownPointerX = event.clientX;
                    onPointerDownPointerY = event.clientY;
                    onPointerDownLon = camera.lon;
                    onPointerDownLat = camera.lat;
                }
            }
        }, false );
        document.addEventListener( 'mousemove', function(event) {
            if (config.freeze) { return; }
            if (camera.isCam0) { return; }
            if (camera.isCamP) {
                if ( isUserInteracting === true ) {
                    camera.lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
                    camera.lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
                } else if (config.raycastUV) {
                    var array = [event.clientX / window.innerWidth, event.clientY / window.innerHeight];
                    if (Math.abs(array[0]-0.5) > 0.45 || Math.abs(array[1]-0.5)>0.45) {
                        // $iBox.fadeOut(); return;
                    }
                    var mesh = camera === config.camera1 ? [config.mesh1] : [config.mesh2];
                    var intersects = getIntersects( new THREE.Vector2().fromArray(array), mesh, true );
                    if ( intersects.length > 0 && intersects[0].uv) {
                        var uv = intersects[0].uv;
                        var pLon = uv.x * 360;
                        var pLat = (uv.y-0.5) * 180;
                        // $info[0].innerHTML = JSON.stringify({ "lon": lon.toFixed(5), "lat": lat.toFixed(5), "u": uv.x.toFixed(5), "v": uv.y.toFixed(5) }, null, 4);
                        $info[0].innerHTML = ""+
                            pLon.toFixed(5) + ", "+
                            pLat.toFixed(5) + "\n"+
                            uv.x.toFixed(5) + ", "+
                            uv.y.toFixed(5) + "\n";
                        var left = event.clientX - $info.width()/2;
                        var bottom = window.innerHeight - event.clientY + 40;
                        $iBox.css({ "left": left, "right": "", "top": "", "bottom": bottom }).show();
                    }
                } else {
                    $iBox.fadeOut();
                }
            }
        }, false );
        container.addEventListener( 'mouseup', function(event) {
            if (config.freeze) { return; }
            if (camera.isCam0) {
                config.gridXZ.visible = config.gridXZ.visible0;
            } else if (camera.lon !== undefined && camera.lat !== undefined) {
                isUserInteracting = false;
                setCursorStyle();
            }
        }, false );
        container.addEventListener( 'wheel', function(event) {
            if (config.freeze) { return; }
            var fov = camera.fov + event.deltaY * 0.05;
            camera.fov = THREE.Math.clamp(Math.round(fov), config.fovMin, config.fovMax);
        }, false );
    }, false);

    var animate = function(time) {
        window.requestAnimationFrame(animate);
        TWEEN.update();

        config.cam0Axis.visible = camera.isCam0 || false;
        config.cam0Axis.position.copy(config.cam0Controls.target);

        if (camera.isCam0) {
            config.cam0Controls.update(config.clock.getDelta());
        } else if (!isDesktop) {
            controls.update();
            // TODO, calculate lon, lat
        } else if (camera.lon !== undefined && camera.lat !== undefined) {
            while (camera.lon > 360) { camera.lon -= 360; }
            while (camera.lon <   0) { camera.lon += 360; }
            camera.lat = Math.max(-85, Math.min(85, camera.lat));
            var v = Util.lonlat2xyz(camera.lon, camera.lat, 500);
            camera.lookAt( new THREE.Vector3(v.x,v.y,v.z).add( camera.position ) );
        }

        config.camera1.position.copy(config.group1.position);
        config.camera2.position.copy(config.group2.position);

        if (!config.freeze) { }

        // cams
        config.camera0.updateProjectionMatrix(); config.cam0Helper.update();
        config.camera1.updateProjectionMatrix(); config.cam1Helper.update();
        config.camera2.updateProjectionMatrix(); config.cam2Helper.update();
        config.cameraX.updateProjectionMatrix(); config.camXHelper.update();

        renderer.render( scene, camera );
    };

    function onKeyDown(event) {
        var code = event.keyCode;
        if (16 <= code && code <= 18) { // shift, control, alt
            return;
        }
        switch (code) {

            case 48: ; break; // 0
            case 49: ; break; // 1
            case 50: ; break; // 2
            case 51: ; break; // 3

            case 52: config.cam0Controls.target.x -= config.deltaMove; break; // 4
            case 53: config.cam0Controls.target.x += config.deltaMove; break; // 5
            case 54: config.cam0Controls.target.z += config.deltaMove; break; // 6
            case 55: config.cam0Controls.target.z -= config.deltaMove; break; // 7

            case 56: config.deltaMove = Math.max(1,  config.deltaMove-1); break; // 8
            case 57: config.deltaMove = Math.min(10, config.deltaMove+1); break; // 9

            case 69: // e
                break;
            case 70: // f
                break;
            case 38: // up
                if (camera !== config.camera0) {
                    config.alpha += 0.01;
                    if (config.alpha > 1.0) {
                        config.alpha = 1.0;
                    }
                    onAlphaChange(config.alpha);
                }
                break;
            case 40: // down
                if (camera !== config.camera0) {
                    config.alpha -= 0.01;
                    if (config.alpha < 0.0) {
                        config.alpha = 0.0;
                    }
                    onAlphaChange(config.alpha);
                }
                break;
            case 37: // left
                if (camera.lon !== undefined) {
                    camera.lon -= 0.25;
                }
                break;
            case 39: // right
                if (camera.lon !== undefined) {
                    camera.lon += 0.25;
                }
                break;

            case 32: // space
                if (camera.isCam0) {
                    config.cam0Controls.target.setScalar(0);
                } else if (camera.isCamP){
                    config.raycastUV = !config.raycastUV;
                }
                break;
            case 13: // enter
                switchToCam();
                break;
            default:
                console.log("keyCode: "+event.keyCode);
        }
    }

    // gui.remember(config);

    $.contextMenu.types.label = function(item, opt, root) {
        $('<span>Label<ul>'
            + '<li class="label1" title="label 1">label 1</li>'
            + '<li class="label2" title="label 2">label 2</li>'
            + '<li class="label3" title="label 3">label 3</li>'
            + '<li class="label4" title="label 4">label 4</li></ul></span>')
            .appendTo(this)
            .on('click', 'li', function() {
                // do some funky stuff
                console.log('Clicked on ' + $(this).text());
                // hide the menu
                // root.$menu.trigger('contextmenu:hide');
            });
        this.addClass('labels').on('contextmenu:focus', function(e) {
            // setup some awesome stuff
        }).on('contextmenu:blur', function(e) {
            // tear down whatever you did
        }).on('keydown', function(e) {
            // some funky key handling, maybe?
        });
    };

    $.contextMenu({
        selector: 'body',
        build: function($triggerElement, event) {
            return {
                selectableSubMenu: true,
                callback: function (key, opt) {
                    console.log("Clicked on " + key + " on element " + opt.$trigger.attr("id"));
                    console.log("Clicked on " + $triggerElement + " on element " + event);
                },
                // animation: "{duration: 250, show: 'fadeIn', hide: 'fadeOut'}",
                // autoHide: true, // buggy on chrome
                // className: 'contextmenu-custom contextmenu-custom',
                events: {
                    show: function (options) {
                        // ...
                    },
                    hide: function (options) {
                        // ...
                    }
                },
                items: {
                    copy: {
                        name: "Copy close",
                        icon: "edit",
                        // accesskey: "cool word" // c
                        // accesskey: "cool word" // w
                        callback: function (key, opt) {
                            console.log("copy close");
                            return true; // close
                        }
                    },
                    copy2: {
                        name: "Copy open",
                        icon: "edit",
                        callback: function (key, opt) {
                            console.log("copy not close");
                            return false;
                        }
                    },
                    copy3: {
                        name: "Copy default callback",
                        icon: "edit"
                    },
                    sep1: "---------",
                    saveAsImage: {
                        name: "Save",
                        icon: "cut",
                        callback: function (key, opt) {
                            var $a = $("<a></a>");
                            $a[0].download = 'image.png';
                            $a[0].href = renderer.domElement.toDataURL();
                            $a.click();
                        }
                    },
                    label: {
                        type: 'label',
                        customName: 'label',
                        callback: function (key, opt) {
                            return false; // open
                        }
                    },
                    sep2: "---------",
                    cut: {
                        name: "如果是 cam0 则 disabled",
                        icon: "cut",
                        disabled: function () {
                            return camera.isCam0 || false;
                        }
                    },
                    fold1: {
                        "name": "Sub group",
                        "items": {
                            "fold1-key1": {"name": "Foo bar"},
                            "fold2": {
                                "name": "Sub group 2",
                                "items": {
                                    "fold2-key1": {"name": "alpha"},
                                    "fold2-key2": {"name": "bravo"},
                                    "fold2-key3": {"name": "charlie"}
                                }
                            },
                            "fold1-key3": {"name": "delta"}
                        }
                    }
                }
            };
        }
    });

    var toggleContext = function() {
        var show = true;
        return function(_show){
            if (_show === undefined) {
                show = !show;
                _show = show;
            }
            $("body").contextMenu(_show);
        };
    }();

</script>

</body>
</html>
